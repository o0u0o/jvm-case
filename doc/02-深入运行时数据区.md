# 02-深入运行时数据区

## 计算机体系结构
**JVM的设计实际上遵循了遵循冯诺依曼计算机结构**
![冯诺依曼计算机](https://images.techgeng.com/blog/Snipaste_2025-03-15_23-09-41.png)

### 摩尔定律

摩尔定律是由英特尔(Intel)创始人之一戈登·摩尔(Gordon Moore)提出来的。其内容为：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18个月翻两倍以上。这一定律揭示了信息技术进步的速度。
> 为了使摩尔定律更为准确，在摩尔定律发现后10年，1975年的时候，摩尔又做了一些修改。将翻番的时间从一年半调整为两年。

**CPU与内存交互图：**
![CPU与内存交互图](https://images.techgeng.com/blog/Snipaste_2025-03-15_23-11-01.png)

### 硬件一致性协议：
MSI、MESI、MOSI、Synapse、Firely、DragonProtocol

整个JVM就是一个进程，在一个进程下有多个线程。它的运行时数据区包含以下内容：
![运行时数据区大致图](https://images.techgeng.com/blog/20250321000018295.png)

JVM的每一个线程，可以与CPU的**运算核心**类比，所以他和CPU的高速缓存与内存的交互一样，也需要保证数据的一致性。

### 常量池分类：
![常量池图解](https://images.techgeng.com/blog/20250321002413040.png)
#### 1.静态常量池

静态常量池是相对于运行时常量池来说的，属于描述class文件结构的一部分

由**字面量**和**符号引用**组成，在类被加载后会将静态常量池加载到内存中也就是运行时常量池

**字面量** ：文本，字符串以及Final修饰的内容

**符号引用** ：类，接口，方法，字段等相关的描述信息。

#### 2.运行时常量池

当静态常量池被加载到内存后就会变成运行时常量池。

> 也就是真正的把文件的内容落地到JVM内存了

#### 3.字符串常量池

**设计理念：**字符串作为最常用的数据类型，为减小内存的开销，专门为其开辟了一块内存区域（字符串常量池）用以存放。

JDK1.6及之前版本，字符串常量池是位于永久代（相当于现在的方法区）。

JDK1.7之后，字符串常量池位于Heap堆中

**面试常问点：（笔试居多）**

下列三种操作最多产生哪些对象

**1.直接赋值**

`String a ="aaaa";`

解析：

最多创建一个字符串对象。

首先“aaaa”会被认为字面量，先在字符串常量池中查找（.equals()）,如果没有找到，在堆中创建“aaaa”字符串对象，并且将“aaaa”的引用维护到字符串常量池中（实际是一个hashTable结构，存放key-value结构数据），再返回该引用；如果在字符串常量池中已经存在“aaaa”的引用，直接返回该引用。

**2.new String()**

`String  a  =new  String("aaaa");`

解析：

最多会创建两个对象。

首先“aaaa”会被认为字面量，先在字符串常量池中查找（.equals()）,如果没有找到，在堆中创建“aaaa”字符串对象，然后再在堆中创建一个“aaaa”对象，返回后面“aaaa”的引用；
**3.intern()**

```java
String s1 = new String("yzt");
String s2 = s1.intern();
System.out.println(s1 == s2); //false
```

解析：

String中的intern方法是一个 native 的方法，当调用 intern方法时，如果常量池已经包含一个等于此String对象的字符串（用equals(object)方法确定），则返回池中的字符串。否则，将intern返回的引用指向当前字符串 s1(jdk1.6版本需要将s1 复制到字符串常量池里)

常量池在内存中的布局：