
解析：
解析是从运行时常量池中的符号引用动态确定具体值的过程
符号引用        ======>     直接引用

![父类委托机制](https://images.techgeng.com/blog/Snipaste_2025-03-20_23-16-24.png)

## 打破父类委托(双亲委派)
双亲委派这个模型并不是强制模型，而且会带来一些些的问题。就比如java.sql.Driver这个东西。 JDK只能提供一个规范接口，而不能提供实现。提供实现的是实际的数据库提供商。提供商的库总不 能放JDK目录里吧。

所以java想到了几种办法可以用来打破我们的双亲委派。

#### SPI(Service Provider Interface) :
比如Java从1.6搞出了SPI就是为了优雅的解决这类问题——JDK 提供接口，供应商提供服务。编程人员编码时面向接口编程，然后JDK能够自动找到合适的实现，岂不是很爽?

>Java 在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实 现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心 类库使用。比如JDBC中的DriverManager

#### OSGI:
比如我们的JAVA程序员更加追求程序的动态性，比如代码热部署，代码热替换。也就是就是机器不用重启，只要部署上就能用。OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。
每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。